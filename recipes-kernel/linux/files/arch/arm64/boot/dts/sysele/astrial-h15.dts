// SPDX-License-Identifier:     GPL-2.0
/*
 * Copyright (c) 2019-2023 Hailo Technologies Ltd. All rights reserved.
 */

/dts-v1/;
#include "../hailo/hailo15-base.dtsi"
#include <dt-bindings/gpio/gpio.h>

/ {
    memory {
        device_type = "memory";
        reg = <0x00000000 0x80000000 0x00000001 0x00000000>;
    };
};

&i2c_1 {
    gyro_lsm6dsr_1: lsm6dsr_1@6b {
        compatible = "st,lsm6dsr";
        reg = <0x6b>;
        vdd-supply = <&regulator_1p8v>;
        vddio-supply = <&regulator_1p8v>;
        interrupt-parent = <&gpio1>;
        interrupts = <14 IRQ_TYPE_EDGE_RISING>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_gpio30>;
	};
};

&i2c_0 {
    status = "ok";

    sensor_0: camera-sensor@1a {
        status = "ok";
        compatible = "sony,imx334", "sony,imx675", "sony,imx678", "sony,imx715";
        reg = <0x1a>;
        clocks = <&sensor_clk>;
        clock-names = "inclk";
        clock-frequency = <24000000>;
        csi-id = <0>;
        reset-gpios = <&gpio0 4 GPIO_ACTIVE_HIGH>;
        xmaster-gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>;
        port {
            sensor_out_csi2rx: endpoint {
                data-lanes = <1 2 3 4>;
                remote-endpoint = <&csi2rx_in_sensor>;
		        link-frequencies = /bits/ 64 <891000000 1440000000 1782000000>;
            };
        };
     };     
};

&csi2rx0 {
    status = "ok";
    ports {
        port@0 {
            csi2rx_in_sensor: endpoint {
                remote-endpoint = <&sensor_out_csi2rx>;
            };
        };
    };
};

&vision_subsys {
    status = "okay";
};

&csi2rx1 {
    status = "ok";
};

&hailo_vid_cap {
    status = "ok";
};

&hailo_isp {
    status = "ok";
};

&hailo_pixel_mux {
    status = "ok";
};

&rxwrapper0 {
    status = "ok";
};

&hailo_vc8000e {
    status = "ok";
};

&vc8000e_reserved {
    status = "ok";
};

&xrp {
    status = "okay";
};

&xrp_reserved {
    status = "okay";
};

&sdio0 {
    status = "ok";
    broken-cd;  // If you don't have a card detect pin
    sdhci-caps= <0 0x01000000>; // Force VOLT33 capability
    max-frequency = <50000000>; // Try limiting the frequency to 50MHz
    bus-width = <4>;           // Make sure we're using 4-bit mode
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_sdio0_gp_in &pinctrl_sdio0_CD_in>;
    phy-config {
        card-is-emmc = <0x0>;  // It's an SD card, not eMMC
        cmd-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        dat-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        rst-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        clk-pad-values = <0x1 0x3 0x0 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        sdclkdl-cnfg = <0x0 0x32>; //extdly_en, cckdl_dc
        drive-strength = <0xC 0xC>; //pad_sp, pad_sn
    };
};

&sdio1 {
    status = "ok";
    broken-cd;
    sdhci-caps= <0 0x01000000>; // Force VOLT33 capability
    phy-config {
		card-is-emmc = <0x0>;
		cmd-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        	dat-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        	rst-pad-values = <0x1 0x3 0x1 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        	clk-pad-values = <0x1 0x3 0x0 0x1>; // txslew_ctrl_n, txslew_ctrl_p, weakpull_enable, rxsel
        	sdclkdl-cnfg = <0x0 0x32>; //extdly_en, cckdl_dc
        	drive-strength = <0xC 0xC>; //pad_sp, pad_sn
    };
};

&eth {
    status = "ok";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_eth>;
};

&qspi {
    status = "ok";

    spi0_flash0: flash@0 {
        /* values for MT25QU01G */
        spi-max-frequency = <6250000>; /* 90Mhz in DTR, 166Mhz in STR */
        cdns,read-delay = <7>;
        cdns,tshsl-ns = <30>;
        cdns,tsd2d-ns = <30>;
        cdns,tchsh-ns = <5>;
        cdns,tslch-ns = <3>;
    };
};

&i2s_cpu_master {
    status = "okay";
    rx-sample-pace-pattern-repetitions = <2>;
    rx-sample-pace = <64 64 64>;
    rx-sample-cmp-to = "prev-val";
    tx-sample-offset = <81>;
    tx-sample-pace = <63>;
};

/ {
    sensor_clk: sensor_clk {
        compatible = "fixed-clock";
        #clock-cells = <0>;
        clock-frequency = <24000000>;
    };
};

&sdio0_reserved {
    status = "ok";
};

&serial0 {
 status = "ok";
};

&i2c_2 {
    status = "ok";
    clock-frequency = <400000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c2>;
    gyro_lsm6dsr_2: lsm6dsr_2@6b {
        status = "disabled";
        compatible = "st,lsm6dsr";
        reg = <0x6b>;
        vdd-supply = <&regulator_1p8v>;
        vddio-supply = <&regulator_1p8v>;
        interrupt-parent = <&gpio1>;
        interrupts = <5 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_gpio21>;
    };

    gyro_icm42670_2: icm42670_2@69 {
        status = "disabled";
        compatible = "invensense,icm42670";
        reg = <0x69>;
        vdd-supply = <&regulator_1p8v>;
        vddio-supply = <&regulator_1p8v>;
        interrupt-parent = <&gpio1>;
        interrupts = <5 IRQ_TYPE_EDGE_RISING>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_gpio21>;
	};
	
    lcd@45 {
        status = "okay";
        compatible = "raspberrypi,10inch-touchscreen-panel";
        reg = <0x45>;
        port {
            panel_in: endpoint {
                remote-endpoint = <&dsi0_out>;
            };
        };
    };
};

&pinctrl {

    pinctrl_gpio30: gpio30 {
        function = "gpio";
        groups = "gpio30_grp";
    };

    pinctrl_eth: eth {
        pins = "eth_rgmii_tx_clk",
               "eth_rgmii_tx_ctl",
               "eth_rgmii_txd_0",
               "eth_rgmii_txd_1",
               "eth_rgmii_txd_2",
               "eth_rgmii_txd_3";
        drive-strength = <2>;
    };

    pinctrl_i2c2: i2c2 {
        function = "i2c2";
        groups = "i2c2_1_grp";
    };

    pinctrl_i2c0_current_src_en_out: i2c0_current_src_en_out {
        function = "i2c0_current_src_en_out";
        groups = "i2c0_current_src_en_out_3_grp";
    };

    pinctrl_i2c1_current_src_en_out: i2c1_current_src_en_out {
        function = "i2c1_current_src_en_out";
        groups = "i2c1_current_src_en_out_4_grp";
    };

    pinctrl_i2c2_current_src_en_out: i2c2_current_src_en_out {
        function = "i2c2_current_src_en_out";
        groups = "i2c2_current_src_en_out_3_grp";
    };

    pinctrl_sdio0_gp_in: sdio0_gp_in {
        function = "sdio0_gp_in";
        groups = "sdio0_gp_in_grp";
    };

    pinctrl_sdio1_gp_in: sdio1_gp_in {
        function = "sdio1_gp_in";
        groups = "sdio1_gp_in_grp";
    };

    pinctrl_sdio0_CD_in: sdio0_CD_in {
        function = "sdio0_CD_in";
        groups = "sdio0_CD_in_grp";
    };

    pinctrl_sdio1_CD_in: sdio1_CD_in {
        function = "sdio1_CD_in";
        groups = "sdio1_CD_in_grp";
    };

    pinctrl_uart0_cts_rts: uart0_cts_rts {
        function = "uart0_cts_rts";
        groups = "uart0_cts_rts_1_grp";
    };

    pinctrl_usb_overcurrent_n_in: pinctrl_usb_overcurrent_n_in {
        function = "usb_overcurrent_in";
        groups = "usb_overcurrent_in_grp";
    };

    pinctrl_usb_drive_vbus_out: pinctrl_usb_drive_vbus_out {
        function = "usb_drive_vbus_out";
        groups = "usb_drive_vbus_out_2_grp";
    };

    pinctrl_gpio21: gpio21 {
        function = "gpio";
        groups = "gpio21_grp";
    };
};

&dsi0 {
    status = "okay";
    ports {
        port@0 {
            reg = <0>;
            dsi0_out: endpoint {
                remote-endpoint = <&panel_in>;
            };
        };
    };
};

#define GPIO_LINE_NAMES \
    "SPI_CS2",                  "SPI_CS3",                  "DSI_RST",                  "CAM_TRIG", \
    "cam0_reset_n",             "cam1_reset_n",             "gpio_in_out_6",            "gpio_in_out_7", \
    "gpio_in_out_8",            "sdio0_gp_in",              "sdio0_cd_in",              "usb_overcurrent_n_in", \
    "usb_drive_vbus_out",       "sdio1_gp_in",              "sdio1_cd_in_n",            "RVSD", \
    \
    "gpio_in_out_16",           "WiFi_BT_disable_n",        "timer_ext_in0",            "timer_ext_in1", \
    "shut_down_out",            "user_LED",                 "i2c2_sda_in_out",          "i2c2_scl_out", \
    "i2c2_current_src_en_out",  "i2c0_current_src_en_out",  "i2c1_current_src_en_out",  "gpio_in_out_27", \
    "gpio_in_out_28",           "DSI_INTR",                 "uart0_cts_pad_in",         "uart0_rts_pad_out"

&gpio0 {
    gpio-ranges = <&pinctrl 0 0 16>;

    gpio-line-names = GPIO_LINE_NAMES;
    
    pin_DSI_RST {
        gpio-hog;
        gpios = <2 GPIO_ACTIVE_HIGH>;
        output-high;
        line-name = "DSI_RST";
    };
};

&gpio1 {
    gpio-ranges = <&pinctrl 0 16 16>;

    gpio-line-names = GPIO_LINE_NAMES;

    pin_WiFi_BT_disable_n {
        gpio-hog;
        gpios = <1 GPIO_ACTIVE_HIGH>;
        output-low;
        line-name = "WiFi_BT_disable_n";
    };

    pin_DSI_INTR {
        gpio-hog;
        gpios = <13 GPIO_ACTIVE_HIGH>;
        output-low;
        line-name = "DSI_INTR";
    };
};

&hailo_torrent_phy {
    status = "okay";
    usb-lane = <3>;
    usb-lane-pma-pll-full-rate-divider = <PCI_PMA_PLL_FULL_RATE_CLK_DIVIDER_4>;
    lanes-config = <PCI_PHY_LINK_LANES_CFG__2x1_PLUS_1x2__MASTER_LANES_LN0_LN2_LN3>;
};

&cdns_torrent_phy {
    torrent_phy_pcie: phy@0 {
        reg = <0>;
        resets = <&scmi_reset HAILO15_SCMI_RESET_IDX_PCIE_PHY_LANE_0>, <&scmi_reset HAILO15_SCMI_RESET_IDX_PCIE_PHY_LANE_1>;
        #phy-cells = <0>;
        cdns,phy-type = <PHY_TYPE_PCIE>;
        cdns,num-lanes = <2>;
    };
    torrent_phy_usb3: phy@3 {
        reg = <3>;
        resets = <&scmi_reset HAILO15_SCMI_RESET_IDX_PCIE_PHY_LANE_3>;
        #phy-cells = <0>;
        cdns,phy-type = <PHY_TYPE_USB3>;
        cdns,num-lanes = <1>;
        cdns,ssc-mode = <TORRENT_SERDES_NO_SSC>;
    };
};

&hailo_usb3 {
    status = "okay";
};

&cdns_usb3 {
    dr_mode = "host";
    phys = <&torrent_phy_usb3>;
    phy-names = "cdns3,usb3-phy";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_usb_overcurrent_n_in>, <&pinctrl_usb_drive_vbus_out>;
};
